<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>SpotypotyPy</title>
    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans&display=swap" rel="stylesheet">

    <style>
        #box {
            display: flex;
            flex-flow: row wrap;
            width: auto;
            height: auto;
            border: 4px solid green;
            /* overflow: hidden; */
        }

        div {
            border: 2px solid pink;
            width: fit-content;
            height: fit-content;
            min-width: 50;
            min-height: 50;
            margin: auto;

        }

        * {

            font-family: 'Open Sans', sans-serif;
        }

        #timeline {
            border: 2px solid black;
            background-color: cadetblue;
            width: auto;
            height: 50px;
            overflow: auto;
            overflow-y: hidden;
            margin: 0 auto;
            white-space: nowrap
        }

        #map {
            border: 2px solid orange;
            width: min-content;
            height: min-content;
        }

        svg {
            border: 2px solid purple;
        }

        span {
            margin: 10px;
        }
    </style>
</head>

<body>


    <div id="box">
        <!-- <h1>SpotypotyPy</h1> -->

        <div id="timeline"></div>

        <div id="modality">
            <!--Nick will make radio buttons for modality-->
        </div>

        <div id="map">
            <svg id="map_svg" width=960 height=600></svg>
        </div>

    </div>
</body>
<script>
    // Example code taken from http://bl.ocks.org/nikhilNathwani/5dca6c63a53934185d05
    var width = 200
    var height = 375

    var week = "2020-12-25--2021-01-01"
    var master_json;
    var mode = "danceability";
    var countryList;
    var proj = d3.geoMercator()
        .translate([250, 250])
        .scale(120);


    var gpath = d3.geoPath()
        .projection(proj);
    var ccolor =
        d3.scaleSequentialQuantile(d3.interpolateReds)
            .domain([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.65, 0.7, 0.75, 0.8, 0.9, 1]

            );

    var svg = d3.select("#modality").append("svg")
        .attr("width", width)
        .attr("height", height);

    // radio background
    var background = svg.append("rect")
        .attr("width", "100%")
        .attr("height", "100%")
        .attr("x", 0)
        .attr("y", 0)
        .attr("rx", 5) // rx and ry give the buttons rounded corners
        .attr("ry", 5)
        .attr("fill", "#191414");

    // container for buttons
    var buttons = svg.append("g")
        .attr("id", "buttons");

    // colors for different button states 
    var defaultColor = "#189a46"
    var hoverColor = "#1db954"
    var pressedColor = "#116e32"

    var labels = ['danceability ðŸ’ƒ', 'energy âš¡', 'loudness ðŸ”Š', 'speechiness ðŸ—£ï¸', 'acousticness ðŸŽ¹', 'instrumentalness ðŸŽº', 'liveness ðŸŽ¤', 'valence ðŸ˜Š', 'tempo ðŸ•°ï¸'];

    // groups for each button, holding rectangle and text
    var buttonGroups = buttons.selectAll("g.button")
        .data(labels)
        .enter()
        .append("g")
        .style("cursor", "pointer")
        .on("click", function (d, i) {
            updateButtons(d3.select(this), d3.select(this.parentNode))
            mode = i.replace(/[^0-9a-z]/gi, '')
            console.log(mode)
            drawMap(gpath, countryList, week, mode, ccolor)
        })
        .on("mouseover", function () {
            if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                d3.select(this)
                    .select("rect")
                    .attr("fill", hoverColor);
            }
        })
        .on("mouseout", function () {
            if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                d3.select(this)
                    .select("rect")
                    .attr("fill", defaultColor);
            }
        });

    var bWidth = width - 30; // button width
    var bHeight = 30; // button height
    var bSpace = 10; // space between buttons
    var x0 = 15; // x offset
    var y0 = 10; // y offset

    // adding a rect to each button group
    buttonGroups.append("rect")
        .attr("width", bWidth)
        .attr("height", bHeight)
        .attr("x", x0)
        .attr("y", function (d, i) { return y0 + (bHeight + bSpace) * i; })
        .attr("rx", 5) // rx and ry give the buttons rounded corners
        .attr("ry", 5)
        .attr("fill", defaultColor)

    // add text to each button group
    buttonGroups.append("text")
        .attr("font-family", "Tahoma")
        .attr("y", function (d, i) {
            return y0 + (bHeight + bSpace) * i + bHeight / 2;
        })
        .attr("x", x0 + bWidth / 2)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central")
        .attr("fill", "white")
        .style("font-size", bWidth / 10 + "px")
        .text(function (d) { return d; })

    function updateButtons(button, parent) {
        parent.selectAll("rect").attr("fill", defaultColor)
        button.select("rect").attr("fill", pressedColor)
    }


    // adapted for d3v6 from book, d3js in action


    Promise.all([
        d3.json('world.geojson'),
        d3.csv('Datasets/weeks_list.csv'),
        d3.json('Datasets/country_key.json')
    ]).then(([countries, weeks, master]) => {
        master_json = master
        countryList = countries
        console.log(master_json)

        createTimeline(weeks)
        createMap(countryList, master_json, week, mode)
    })

    function createTimeline(weeks) {
        // var timeline = d3.select("#timeline")
        // console.log(weeks)

        d3.select("#timeline")
            .selectAll("p")
            .data(weeks)
            .enter()
            .append("span")
            .text(function (d) {
                // console.log(d.week);
                return d.week;
            })
            .attr("id", function (d) {
                return d.week;
            });
    }

    function drawMap(gpath, countries, week, mode, ccolor) {
        console.log("drawing map...")
        document.getElementById('map_svg').innerHTML = "";
        d3.select('#map_svg')
            .selectAll('path')
            .data(countries.features)
            .enter()
            .append('path')
            .attr('d', function (d) { return gpath(d); })
            .attr('stroke-width', 1)
            .attr('stroke', '#252525')
            .attr('country', d => d.id)
            // .on('mouseover', function (d) {
            //     console.log( d.id)
            // })
            .attr('fill', function (d) {

                var country = master_json[d.id]
                console.log(country)
                // not every country is represented in the data, so check whether or not we have data
                if (typeof (country) !== 'undefined') {
                    // console.log(country[week][mode])
                    return ccolor(country[week][mode]);
                }
            })
    }
    function createMap(countries, master_json, week, mode) {
        console.log(countries)
        console.log(master_json)
        console.log(week)
        console.log(mode)

        console.log(gpath.area(countries.features[1]));

        console.log(gpath.area(countries.features[1]));

        // draw country boundaries

        drawMap(gpath, countries, week, mode, ccolor)

        var mapZoom = d3.zoom()
            .on('zoom', zoomed);

        var zoomSettings = d3.zoomIdentity
            .translate(250, 250)
            .scale(120);

        d3.select('#map_svg')
            .call(mapZoom)
            .call(mapZoom.transform, zoomSettings);

        function zoomed(e) {
            proj
                .translate([e.transform.x, e.transform.y])
                .scale(e.transform.k);

            console.log(e.transform.k);
            if (e.transform.k > 400)
                console.log('toggle adaptive map feature');

            // redraw map with new projection settings
            d3.selectAll('path')
                .attr('d', gpath);

            d3.selectAll('circle')
                .attr('cx', d => proj([d.x, d.y])[0])
                .attr('cy', d => proj([d.x, d.y])[1])
        }

    }
</script>

</html>